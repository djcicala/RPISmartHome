#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''****************************************************************************
* File Name: water_lawn.py                                                    *
* Purpose:   Methods and functions pertaining to the water lawn module.       *
* Date:      12/05/2019                                                       *
* Copyright Â© 2019 Darren Cicala and Tyler Skene. All rights reserved.        *
* Powered by the DarkSky API.                                                 *
****************************************************************************'''

# document version
__version__ = "2.0.0"

# imports 
import configs                # global configs file for the system
import urllib.request         # library to handle HTTPGet requests
import json                   # library to handle JSON parsing
from Adafruit_GPIO import SPI # library for SPI communication
import Adafruit_MCP3008       # library for decoding the output of the ADC
import datetime               # library for time capturing
import time

# class to take in and handle forecast information from the API
class Forecast:
  
  '''*****************************************************************
  * Name: __init__                                                                  
  * Description: Constructor for class Forecast                      
  * Parameters:  N/A                    
  * Returns:     N/A                     
  *****************************************************************'''   
  def __init__(self):
    # get the API string from the configs file
    self.s_APILink = configs.s_FullAPI   
    # make an API request 
    s_Contents = urllib.request.urlopen(self.s_APILink).read().decode("utf-8") 
    # dump the return string into a dictionary
    self.d_ForecastInformation = json.loads(s_Contents)
  
  '''*****************************************************************
  * Name: update                                                                  
  * Description: Updates the forecast class with a fresh API call.                      
  * Parameters:  N/A                    
  * Returns:     int i_Error
  *                  Error flag generated by the API call failing.                     
  *****************************************************************'''    
  def update(self):
    # make an API request 
    s_Contents = urllib.request.urlopen(self.s_APILink).read().decode("utf-8") 
    if s_Contents == "":
      return configs.SYSERROR_WL_API_CALL_FAILURE
    else:
      # dump the return string into a dictionary
      self.d_ForecastInformation = json.loads(s_Contents)
      # capture the hourly forecasts for ease of access 
      self.l_HourlyForecasts = self.d_ForecastInformation["hourly"]["data"]
      self.l_DailyForecasts  = self.d_ForecastInformation["daily"]["data"]
      self.CheckForRain()
      return configs.SYSERROR_NO_ERROR
  
  '''*****************************************************************
  * Name: CheckForRain                                                                  
  * Description: Sets a flag if rain is predicted to happen in the next
  *              twelve hours.                      
  * Parameters:  N/A                    
  * Returns:     N/A                     
  *****************************************************************'''   
  def CheckForRain(self):
    
    self.i_Rain = 1
    for each_forecast in self.l_HourlyForecasts:
      if(each_forecast["precipProbability"] > 0.40):
        self.i_Rain = 1
        return
    self.i_Rain = 0

# class to handle the water sensor component    
class WaterSensor:
    
  '''*****************************************************************
  * Name: __init__                                                                  
  * Description: Constructor for class WaterSensor. Sets up SPI device                      
  * Parameters:  N/A                    
  * Returns:     N/A                     
  *****************************************************************'''  
  def __init__(self):
    self.o_AdcDevice = Adafruit_MCP3008.MCP3008(spi=SPI.SpiDev(configs.i_SPIDevice, configs.i_SPIPort))
  
  '''*****************************************************************
  * Name: read                                                                  
  * Description: Reads data from the ADC SPI bus. If a short is detected,
  *              it raises an error flag.                       
  * Parameters:  N/A                    
  * Returns:     int i_Error
  *                  Error flag raised if a short is detected.                    
  *****************************************************************'''    
  def read(self):
      
    # first get the digital value from the ADC  
    i_DigitalValue = self.o_AdcDevice.read_adc_difference(configs.i_AdcChannel)
    
    # a short is detected if we get max current across the sensor probes
    if(i_DigitalValue == configs.i_WaterSensorScalar):
      return configs.SYSERROR_WL_MOISTURE_SENSOR_FAILURE
      
    # otherwise, scale the ADC value into a percentage
    else:
      self.f_WaterLevel_Pct = 100 * (i_DigitalValue / configs.i_WaterSensorScalar)
      return configs.SYSERROR_NO_ERROR

# class to act as main loop for the water module      
class WaterModule:
    
  '''*****************************************************************
  * Name: __init__                                                                  
  * Description: Constructor for class WaterModule.                      
  * Parameters:  obj o_InputSysTime
  *                  Systime object shared between modules.
  *              obj o_OutdoorTemperatureSensor
  *                  Outdoor temperature sensor from the temperature module.                   
  * Returns:     N/A                     
  *****************************************************************'''  
  def __init__(self, o_InputSysTime, o_OutdoorTemperatureSensor):
    self.o_WaterSensor = WaterSensor()
    self.o_Forecast = Forecast()
    self.o_OutdoorTempSensor = o_OutdoorTemperatureSensor
    self.o_SysTime = o_InputSysTime
    self.i_WaterFlag = 0
    self.f_SoilMoistureWilt = configs.f_Wilt
    self.f_SoilMoistureCapacity = configs.f_Capacity
  
  '''*****************************************************************
  * Name: ReadSensors                                                                  
  * Description: Reads fresh data from both the outdoor temp sensor and the
  *              water sensor.                      
  * Parameters:  N/A                    
  * Returns:     int i_Error
  *                  Error code raised by system.                  
  *****************************************************************'''                                                
  def ReadSensors(self):
    # read from the water sensor, if an error, return
    i_Error = self.o_WaterSensor.read()
    if(i_Error != configs.SYSERROR_NO_ERROR):
      return i_Error
    
    # read from the outdoor temperature sensor, if an error, return  
    self.o_OutdoorTempSensor.read()
    if(self.o_OutdoorTempSensor.f_Temperature_C == None):
      i_Error = configs.SYSERROR_TEMP_OUTDOOR_SENSOR_FAILURE
      return i_Error

    # otherwise, return no error
    else:
      return i_Error
    
  '''*****************************************************************
  * Name: MakeWateringDecision                                                                  
  * Description: Makes the decision to water the lawn based on the temperature
  *              and the wetness of the soil.                      
  * Parameters:  N/A                    
  * Returns:     int i_Error
  *                  Error code raised by system.                       
  *****************************************************************'''   
  def MakeWateringDecision(self):
    #get refreshed values
    i_Error = self.o_Forecast.update()
    
    if(i_Error == configs.SYSERROR_NO_ERROR):
      # if the temperature is below 40 F or rain is forecasted, do not water 
      if self.o_OutdoorTempSensor.f_Temperature_F < 40 or self.o_Forecast.i_Rain == 1:
        self.i_WaterFlag = 0
      
      # otherwise if we are currently watering
      elif self.i_WaterFlag == 1 and datetime.datetime.now() >= self.o_LastWaterTime:
        
        # if the soil is too wet, stop watering
        if self.o_WaterSensor.f_WaterLevel_Pct > self.f_SoilMoistureCapacity:
          self.i_WaterFlag = 0
        # otherwise, update the timestamp
        else:
          self.o_LastWaterTime = datetime.datetime.now()
      # if we are not currently watering
      elif self.i_WaterFlag == 0:
        # if the soil is dry, start watering
        if self.o_WaterSensor.f_WaterLevel_Pct < self.f_SoilMoistureWilt:
          self.i_WaterFlag = 1
          self.o_LastWaterTime = datetime.datetime.now()  
      # return with no error
      return configs.SYSERROR_NO_ERROR
    # otherwise, return the error
    else:
      return i_Error
  
  '''*****************************************************************
  * Name: main                                                                 
  * Description: Main loop of the water lawn module.                    
  * Parameters:  N/A                    
  * Returns:     int i_Error
  *                  Error code raised by system.                       
  *****************************************************************'''                                                
  def main(self):
    print("========================Start Water Lawn Module")
    
    # first read the sensors, then make the watering decision
    i_Error = self.ReadSensors()
    if(i_Error == configs.SYSERROR_NO_ERROR):
      i_Error = self.MakeWateringDecision()                                          
      print("Should we water?: " + str(self.i_WaterFlag))
      print("Water percentage: " + str(self.o_WaterSensor.f_WaterLevel_Pct))
    print("========================End Water Lawn Module")
    return i_Error


################################## end file ###################################
